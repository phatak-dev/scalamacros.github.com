\documentclass[hyperref={bookmarks=false}]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[parfill]{parskip}

\usepackage{color}
\usepackage{listings}
\usepackage{hyperref}
\hypersetup{pdfauthor={Eugene Burmako},pdfsubject={Project Kepler},pdftitle={Alpha Kepler}}
\title{Alpha Kepler}

\definecolor{linkblue}{RGB}{49,57,174}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinelanguage{scala}{
  morekeywords={abstract,annotation,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield,
    macro},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{План}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}

\title{$\alpha$-Кеплер}
\author{Евгений Бурмако}
\institute{EPFL, LAMP}
\date{14 января 2012}
\maketitle

\begin{frame}[t,fragile]
\frametitle{$\alpha$-Кеплер}

Всем привет! Меня зовут Евгений Бурмако, с прошлой осени я работаю в Scala Team и параллельно учусь в аспирантуре EPFL на кафедре Мартина Одерского.

Сегодня мы обсудим прогресс проекта ``Кеплер'', в рамках которого реализуются \textbf{макросы} и \textbf{квазицитаты} - средства метапрограммирования времени компиляции для Скалы. В процессе общения мы реализуем одну штуку, о которой я мечтал со времен знакомства с Немерле. Также мы поговорим о том, какие незапланированные применения макросов нашлись в процессе работы над проектом.

В \text{\color{linkblue}\href{http://scalamacros.org/news/2011-10-29-talk-at-scalaby-meetup.html}{предыдущем выступлении}} я рассматривал макросы с теоретической точки зрения, а сегодня будет, в основном, практика. Поэтому перед тем, как продолжить чтение, может быть полезно просмотреть {\color{linkblue}\href{http://scalamacros.org/talks/2011-10-29-RuProjectKepler.pdf}{слайды прошлого рассказа}}.
\end{frame}

\section{Введение в макросы}

\begin{frame}[t,fragile]
\frametitle{Начнем издалека}

Одним из интересных событий этой осени в мире Скалы стало обсуждение \text{\color{linkblue}\href{https://docs.google.com/document/d/1NdxNxZYodPA-c4MLr33KzwzKFkzm9iW9POexT9PkJsU/edit?hl=en_US&pli=1}{интерполяции строк}}.

Эта функциональность встречается во многих скриптовых языках (bash, Perl, Ruby) и предоставляет возможность встраивать в строки переменные из лексического окружения.

\begin{lstlisting}[language=scala]
scala> val world = "world"
world: String = world

scala> println(s"hello ${world}!")
hello world!
\end{lstlisting}%$

Буква \texttt{s}, стоящая прямо перед строкой - не опечатка, а обозначение того, что строка интерполируется (в целях обратной совместимости доллары в обычных строках не будут интерпретироваться специальным образом).
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Реализация интерполятора}

Несмотря на свою простоту, интерполяция не поддается библиотечной реализации, так как она оперирует лексическим окружением, которое в явном виде недоступно.

В рамках смелого научного эксперимента нам придется открыть \texttt{doTypedApply} (функцию, которая типизирует применение методов) и вставить проверку на метод интерполяции. Внутри компилятора у нас есть полный доступ ко всей семантической информации о программе, чем мы и воспользуемся.

В тайпере возможно получить строковый литерал, который требуется проинтерполировать, и прямо на месте распарсить этот литерал. После этого, пройдясь по дереву контекстов, несложно составить словарь видимых переменных и превратить вызов метода \texttt{s} в обычную конкатенацию строк.

Если очень интересно, детали реализации можно посмотреть \text{\color{linkblue}\href{https://github.com/scalamacros/kepler/blob/09d1aed7e2353d93aaf703bbae83c1f4322cd450/src/compiler/scala/tools/nsc/typechecker/Quasiquoter.scala\#L94}{у меня в репозитории}}, а пока что пойдем дальше.
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Использование интерполятора}

Пока что все было довольно несложно. Мы встроились в тайпер и заменили вызов функции-маркера на вручную собранное дерево. Звучит страшнее, чем оно есть на самом деле. Через несколько слайдов мы будем заниматься тем же самым в режиме лайв =)

Единственный вопрос в том, как использовать наш патч к компилятору. Интерполяция выглядит более-менее серьезно, но вот трюки, специфичные для проекта, в апстрим явно не примут, а таскать за собой кастомную сборку компилятора неудобно по многим причинам.

Общепринятым решением в данной ситуации является написание \text{\color{linkblue}\href{http://www.scala-lang.org/node/140}{плагина к компилятору}} (например, CPS в Скале реализован именно через плагин), а это очень близко к философии макросов. Мы почти на месте.
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Что такое макросы?}

Макросы - специального вида плагины к компилятору, которые автоматически загружаются из classpath и преобразуют заданные элементы программы (вызовы функций, ссылки на типы, объявления классов и методов).

По аналогии с рассмотренным выше примером макросы:
\begin{itemize}
\item Выполняются во время компиляции
\item В отличие от традиционных плагинов прозрачно загружаются компилятором, не требуя оборачивания в \texttt{Plugin} и \texttt{Component}
\item Работают с деревьями выражений, которые соответствуют коду компилируемой программы
\item Имеют доступ к внутренним сервисам компилятора (рефлексия ранее скомпилированного кода, вывод и проверка типов, лексические окружения и так далее)
\end{itemize}
\end{frame}


\begin{frame}[t,fragile]
\frametitle{Какие бывают макросы?}

Макро-функции получают на вход AST аргументов, раскрываются в AST и инлайнятся в точку вызова.

\begin{lstlisting}[language=scala]
macro def printf(format: String, params: Any*) = ...
printf("Value = %d", 123 + 877)
\end{lstlisting}

Макро-типы представляют собой типы, члены которых генерируются во время компиляции:

\begin{lstlisting}[language=scala]
macro class MySqlDb(connString: String) = ...
object MyDb extends MySqlDb("Database=Foo;")
\end{lstlisting}

Макро-аннотации выполняют пост-обработку объявлений методов и типов:

\begin{lstlisting}[language=scala]
macro annotation Serializable(implicit ctx: Context) = ...
@Serializable case class Person(name: String)
\end{lstlisting}
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Отклик}

За несколько месяцев жизни проекта ``Кеплер'' нашлось немало практических задач, которые сильно упрощаются при наличии макросов.

Уже есть желающие использовать макросы для реализации языка запросов в O/RM, я слышал о планах использовать макро-аннотации в линзах, есть идеи насчет применения макро-типов для генерации бойлерплейта, необходимого для вычислений на типах. Буквально позавчера Мартин \text{\color{linkblue}\href{https://github.com/odersky/scala/commit/35b36229b189a840756330049fa1c7094a309036}{реализовал прототип оптимизатора}}, который использует макросы для ускорения \texttt{Range.foreach}.

Наша лаборатория выиграла грант \text{\color{linkblue}\href{http://www.kti.admin.ch/index.html?lang=en}{Швейцарской комиссии по технологиям и инновациям}} на разработку усовершенствования Скалы, в основе которого лежат рефлексия и макросы.
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Статус}

На сегодняшний момент мы переосмыслили публичный интерфейс к компилятору и его структурам данных и воплотили в жизнь \text{\color{linkblue}\href{https://github.com/scalamacros/kepler/branches/topic/macros}{прототип компилятора}}, который реализует макро-функции. Мы довольны тем, как выглядит прототип, и будем дальше двигаться в этом направлении.

В активной разработке находятся \text{\color{linkblue}\href{http://xeno-by.livejournal.com/69111.html}{квазицитаты}} - доменно-специфический язык для создания и декомпозиции абстрактных синтаксических деревьев. Скорее всего, они будут реализованы как обобщение \text{\color{linkblue}\href{https://docs.google.com/document/d/1NdxNxZYodPA-c4MLr33KzwzKFkzm9iW9POexT9PkJsU/edit?hl=en_US&pli=1}{строковой интерполяции}}, но здесь гораздо меньше ясности, чем с макросами.

Мы опубликовали сайт \text{\color{linkblue}\href{http://scalamacros.org}{scalamacros.org}}, на котором собраны материалы по нашему проекту. Особый интерес, на наш взгляд, составляет раздел \text{\color{linkblue}\href{http://scalamacros.org/usecases.html}{``Use Cases''}}, в котором рассматриваются области применения макросов.
\end{frame}

\section{Пишем макрос для регулярок}

\begin{frame}
\frametitle{Демонстрация}
(В оффлайновой версии слайдов тут будет транскрипт нашей сессии кодинга)
\end{frame}

\section{Пару слов о квазицитатах}

\begin{frame}[t,fragile]
\frametitle{Квазицитаты}

В процессе демонстрации был задан вопрос. "Собирать деревья вручную неудобно. Но ведь парсер компилятора умеет преобразовывать код на Скале в деревья. Почему бы не создавать деревья, пользуясь их строковым представлением?"

Ответ на этот вопрос положительный - действительно, можно упростить создание AST с помощью языковой фичи, известной под названием "квазицитирование". 

Я хотел обойти эту тему стороной потому, что дизайн квазицитат (в отличие от макросов) даже близко не завершен, поэтому финальная версия может радикально отличаться от текущего прототипа. 

Однако предоставляемый квазицитатами функционал действительно очень важен, поэтому мы немного поговорим на эту тему на следующих слайдах. Более подробно теория разобрана в \text{\color{linkblue}\href{http://scalamacros.org/news/2011-10-29-talk-at-scalaby-meetup.html}{предыдущем выступлении}}.
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Что умеют квазицитаты?}

Квазицитаты превращают строки с кодом в эквивалентные синтаксические деревья:

\begin{lstlisting}[language=scala]
val two = scala"2"
Literal(Constant(2))
\end{lstlisting}

Маленькие квазицитаты можно вставлять в большие при помощи сплайсинга:

\begin{lstlisting}[language=scala]
val four = scala"$two + $two"
Apply(Select(two, newTermName("$plus")), List(two))
\end{lstlisting}%$

Квазицитаты можно использовать слева от стрелочки при паттерн-матчинге:

\begin{lstlisting}[language=scala]
four match { case "2 + $x" => println(showRaw(x)) }
Literal(Constant(2))
\end{lstlisting}%$
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Обобщенные квазицитаты}
Механизм квазицитирования можно обобщить для встраивания совершенно чужеродных доменно-специфических языков.

Реализовав парсинг, сплайсинг (и, возможно, паттерн-матчинг) для DSL, программист обеспечивает тесную интеграцию языка с Scala. Для использования провайдера необходимо просто задать идентификатор провайдера перед строчкой с квазицитатой.

Провайдер квазицитаты выполняется во время компиляции, поэтому он может использовать семантическую информацию о программе (таблицы символов, сервис проверки типов, и т.д.), а также выполнять прекомпиляцию (аналогично тому, как мы это делали для регексов).

Интересные способы применения квазицитат для создания доменно-специфических языков рассматриваются в работе \text{\color{red}\href{TODO!}{Why It’s Nice to be Quoted: Quasiquoting for Haskell}}.

\end{frame}

\section{Заключение}

\begin{frame}[t,fragile]
\frametitle{Резюме}
\begin{itemize}
\item Механизм макросов предоставляет прозрачные точки расширения компилятора. С помощью макросов можно  анализировать и оптимизировать код, генерировать бойлерплейт и \text{\color{linkblue}\href{http://scalamacros.org/usecases.html}{многое другое}}.
\item Макросы в Скале - это уже реальность. В ближайшем будущем мы выпустим бета-версию и представим пропоузал по добавлению макросов в 2.10.
\item Интересное направление исследования - квазицитаты. Они не только упрощают работу с макросами, но и позволяют интегрировать в Скалу внешние DSL. Эта фича находится на более ранней стадии по сравнению с макросами, но мы постараемся успеть допилить ее к 2.10.
\item По шагам нашей демонстрации уже сейчас можно поэкспериментировать со своими собственными макросами. Если что-то не получится - напишите мне на \text{\color{linkblue}\href{mailto:eugene.burmako@epfl.ch}{eugene.burmako@epfl.ch}}, разберемся вместе.
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Что дальше?}

Наш следующий шаг - стабилизация рефлексии (которая используется макросами для доступа к деревьям и компилятору) и выпуск бета-версии макросов.

Вместе с бета-версией мы опубликуем документы в рамках Scala Improvement Process, в которых предложим включить макросы и, возможно, квазицитаты в версию 2.10 (которая выйдет в первой половине года).

За новостями можно следить по следующим направлениям: \text{\color{linkblue}\href{http://scalamacros.org/news.html}{новости на scalamacros.org}} (официальные объявления), \text{\color{linkblue}\href{http://xeno-by.livejournal.com/tag/macros2011}{посты в моем ЖЖ}} (дизайн-заметки и майлстоуны), \text{\color{linkblue}\href{http://www.twitter.com/\#!/xeno_by}{мессаги в моем твиттере}} (с этим все понятно :)).

Наконец, за развитием проекта можно наблюдать на гитхабе: \text{\color{linkblue}\href{https://github.com/scalamacros/kepler}{https://github.com/scalamacros/kepler}}.Основная разработка ведется в \texttt{topic/macros}, экспериментальные вещи (вроде квазицитат) имеют собственные бранчи.
\end{frame}

\begin{frame}[c, fragile]
\frametitle{}

\centering
{\Large Вопросы и ответы}\\

\centering
\text{\color{linkblue}\href{mailto:eugene.burmako@epfl.ch}{eugene.burmako@epfl.ch}}

\end{frame}

\end{document}
