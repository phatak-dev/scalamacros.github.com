---
layout: default
title: Getting started
comments: false
plusone: true
---

<p>
  There's a <a href="http://eed3si9n.com/ja/scala-macros-getting-started">Japanese translation</a> of this guide, courtesy of Eugene Yokota.
</p>

<h2>1. Getting Scala 2.10</h2>

<p>Follow the instructions on the <a href="/download.html">Download</a> page to get a macro-enabled Scala compiler.
You can download it manually or reference it in Maven or SBT - pick your favorite way.</p>

<h2>2. Writing a macro</h2>

<p>Create a file named <code>Macros.scala</code> and paste the following code (be sure to follow the comments in the code,
they reveal important things to know about our macro system, accompanying APIs and infrastructure):</p>

{% highlight scala %}
import scala.reflect.macros.Context
import collection.mutable.ListBuffer
import collection.mutable.Stack

object Macros {
  // macro definition is a normal function with anything you fancy in its signature
  // its body, though, is nothing more that a reference to an implementation
  def printf(format: String, params: Any*): Unit = macro printf_impl

  // macro implementation must correspond to macro definitions that use it
  // required signature is quite involved, but don't be scared
  // if the compiler is unhappy, it will print the signature it wants in the error message
  def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = {
    // compiler API is exposed in scala.reflect.macros.Context
    // its most important part, reflection API, is accessible via c.universe
    // it's customary to import c.universe._, because it includes a lot of routinely used stuff
    import c.universe._

    // first of all, we parse the provided format string
    // macros run during the compile-time, so they operate on trees, not on values
    // this means that the format parameter of our macro will be a compile-time literal
    // not an object of type java.lang.String
    // this also means that the code below won't work for printf(get_format(), ...)
    // because in that case format won't be a string literal
    // but rather an AST that represents addition of two string literals
    // adjusting the macro to work for arbitrary stuff is left as an excercise for the reader
    val Literal(Constant(s_format: String)) = format.tree

    // here we jump straight into the compiler
    // the paragraph below creates temporary vals that precompute expressions being formatted
    // to learn more about dynamic generation of Scala code, take a look at our slides:
    // http://scalamacros.org/talks/2012-04-28-MetaprogrammingInScala210.pdf
    val evals = ListBuffer[ValDef]()
    def precompute(value: Tree, tpe: Type): Ident = {
      val freshName = newTermName(c.fresh("eval$"))
      evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)
      Ident(freshName)
    }

    // nothing fancy here, just bread and butter AST manipulations
    // extract trees from parameters of a macro, decompose/analyze and transform them
    // note how we get a hold of Scala types that correspond to Int and String
    // this works for a small set of core types
    // but in most cases you will have to create types by yourself
    // read up the aforementioned slides to learn more about types
    val paramsStack = Stack[Tree]((params map (_.tree)): _*)
    val refs = s_format.split("(?<=%[\\w%])|(?=%[\\w%])") map {
      case "%d" => precompute(paramsStack.pop, typeOf[Int])
      case "%s" => precompute(paramsStack.pop, typeOf[String])
      case "%%" => Literal(Constant("%"))
      case part => Literal(Constant(part))
    }

    // now we combine all the code we have generated into a Block
    // note the call to reify, which provides a shortcut for creating ASTs
    // learn more about reify in our documentation
    val stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)
    c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))
  }
}
{% endhighlight %}

<h2>3. Compiling a macro</h2>

<p>Ready to go? Type <code>scalac Macros.scala</code>, and let's have some fun.</p>

{% highlight bash %}
C:/Projects/Kepler/sandbox>scalac Macros.scala
Macros.scala:8: error: macro definition needs to be enabled
by making the implicit value language.experimental.macros visible.
This can be achieved by adding the import clause 'import language.experimental.macros'
or by setting the compiler option -language:experimental.macros.
See the Scala docs for value scala.language.experimental.macros for a discussion
why the feature needs to be explicitly enabled.
  def printf(format: String, params: Any*): Unit = macro printf_impl
      ^
one error found
{% endhighlight %}

<p>Not so fast! Macros are considered an experimental and advanced feature, so they need to be enabled explicitly.
Do that either with <code>import language.experimental.macros</code> on per-file basis
or with <code>-language:experimental.macros</code> (providing a compiler switch) on per-compilation basis.</p>

{% highlight bash %}
C:/Projects/Kepler/sandbox>scalac -language:experimental.macros Macros.scala
<scalac has exited with code 0>
{% endhighlight %}

<h2>4. Using a macro</h2>

<p>Create a file named <code>Test.scala</code> and and paste the following code (just as simple as that,
to use a macro, you just import it and call it as it were a regular function):</p>

{% highlight bash %}
object Test extends App {
  import Macros._
  printf("hello %s!", "world")
}
{% endhighlight %}

{% highlight bash %}
C:/Projects/Kepler/sandbox>scalac Test.scala
<scalac has exited with code 0>

C:/Projects/Kepler/sandbox>scala Test
hello world!
{% endhighlight %}

<p>Wow, it seems to work! Let's see what happens under the covers by enabling <code>-Ymacro-debug-lite</code> compiler flag
(there are other macro-related flags defined in <a href="https://github.com/scala/scala/blob/master/src/compiler/scala/tools/nsc/settings/ScalaSettings.scala">ScalaSettings.scala</a>,
if you're curious give them a try):</p>

{% highlight bash %}
C:/Projects/Kepler/sandbox>scalac -Ymacro-debug-lite Test.scala
typechecking macro expansion Macros.printf("hello %s!", "world") at
source-C:/Projects/Kepler/sandbox\Test.scala,line-3,offset=52
{
  val eval$1: String = "world";
  scala.this.Predef.print("hello ");
  scala.this.Predef.print(eval$1);
  scala.this.Predef.print("!");
  ()
}
Block(List(
ValDef(Modifiers(), newTermName("eval$1"), TypeTree().setType(String), Literal(Constant("world"))),
Apply(
  Select(Select(This(newTypeName("scala")), newTermName("Predef")), newTermName("print")),
  List(Literal(Constant("hello")))),
Apply(
  Select(Select(This(newTypeName("scala")), newTermName("Predef")), newTermName("print")),
  List(Ident(newTermName("eval$1")))),
Apply(
  Select(Select(This(newTypeName("scala")), newTermName("Predef")), newTermName("print")),
  List(Literal(Constant("!"))))),
Literal(Constant(())))
{% endhighlight %}

<p>With <code>-Ymacro-debug-lite</code> you can see both pseudo-Scala representation of the code generated by macro expansion
and raw AST representation of the expansion. Both have their merits: the former is useful for surface analysis, while the latter
is invaluable for fine-grained debugging.</p>

<h2>5. Important notes</h2>

<p>First of all, note that the listing in the previous section didn't include <code>-language:experimental.macros</code>.
That's because only declaring macros is hidden behind a flag, calling macros is free for all.</p>

<p>Another important aspect of macrology is separate compilation. To perform macro expansion, compiler needs a macro implementation in executable form.
Thus macro implementations need to be compiled before the main compilation, otherwise you might see the following error:</p>

{% highlight bash %}
C:/Projects/Kepler/sandbox>scalac -language:experimental.macros Macros.scala Test.scala
Test.scala:3: error: macro implementation not found: printf (the most common reason for that is that
you cannot use macro implementations in the same compilation run that defines them)
pointing to the output of the first phase
  printf("hello %s!", "world")
        ^
one error found
{% endhighlight %}

<p>What's even more funny. If there's a previous version of a compiled macro on your classpath, then
joint compilation of macro implementations and macro usages will make the compiler call a stale version of your macro.
This might result in <code>NoClassDefFoundException</code>, <code>AbstractMethodError</code> and their friends.
Therefore always go for separate compilation, unless you're well aware of what you're doing.</p>

<p>One more experiment. What happens if macro throws an unhandled exception?
For example, let's crash our macro by providing invalid input:</p>

{% highlight bash %}
C:/Projects/Kepler/sandbox>scalac -language:experimental.macros Macros.scala
<scalac has exited with code 0>

C:/Projects/Kepler/sandbox>scala
Welcome to Scala version 2.10.0-20120428-232041-e6d5d22d28 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_25).
Type in expressions to have them evaluated.
Type :help for more information.

scala> import Macros._
import Macros._

scala> printf("hello %s!")
<console>:11: error: exception during macro expansion:
java.util.NoSuchElementException: head of empty list
        at scala.collection.immutable.Nil$.head(List.scala:318)
        at scala.collection.immutable.Nil$.head(List.scala:315)
        at scala.collection.mutable.Stack.pop(Stack.scala:140)
        at Macros$$anonfun$1.apply(Macros.scala:49)
        at Macros$$anonfun$1.apply(Macros.scala:47)
        at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:237)
        at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:237)
        at scala.collection.IndexedSeqOptimized$class.foreach(IndexedSeqOptimized.scala:34)
        at scala.collection.mutable.ArrayOps.foreach(ArrayOps.scala:39)
        at scala.collection.TraversableLike$class.map(TraversableLike.scala:237)
        at scala.collection.mutable.ArrayOps.map(ArrayOps.scala:39)
        at Macros$.printf_impl(Macros.scala:47)

              printf("hello %s!")
                    ^
{% endhighlight %}

<p>Nothing dramatic has happened. Compiler guards itself against misbehaving macros, prints relevant part of a stack trace,
and reports an error.</p>

<h2>6. Writing bigger macros</h2>

<p>When the code of a macro implementation grows big enough to warrant modularization beyond the body of the implementation method, it becomes apparent that one needs to carry around the context parameter, because most things of interest are path-dependent on the context.</p>

<p>One of the approaches is to write a class that takes a parameter of type <code>Context</code> and then split the macro implementation into a series of methods of that class. This is natural and simple, except that it's hard to get it right. Here's a typical compilation error.</p>

{% highlight scala %}
scala> class Helper(val c: Context) {
     | def generate: c.Tree = ???
     | }
defined class Helper

scala> def impl(c: Context): c.Expr[Unit] = {
     | val helper = new Helper(c)
     | c.Expr(helper.generate)
     | }
<console>:32: error: type mismatch;
 found   : helper.c.Tree
    (which expands to)  helper.c.universe.Tree
 required: c.Tree
    (which expands to)  c.universe.Tree
       c.Expr(helper.generate)
                     ^
{% endhighlight %}

<p>The problem in this snippet is in a path-dependent type mismatch. The Scala compiler does not understand that <code>c</code> in impl</code> is the same object as <code>c</code> in <code>Helper</code>, even though the helper is constructed using the original <code>c</code>.</p>

<p>Luckily just a small nudge is all that is needed for the compiler to figure out what's going on. One of the possible ways of doing that is using refinement types (the example below is the simplest application of the idea; for example, one could also write an implicit conversion from <code>Context</code> to <code>Helper</code> to avoid explicit instantiations and simplify the calls).</p>

{% highlight scala %}
scala> abstract class Helper {
     | val c: Context
     | def generate: c.Tree = ???
     | }
defined class Helper

scala> def impl(c1: Context): c1.Expr[Unit] = {
     | val helper = new { val c: c1.type = c1 } with Helper
     | c1.Expr(helper.generate)
     | }
impl: (c1: scala.reflect.macros.Context)c1.Expr[Unit]
{% endhighlight %}

<p>An alternative approach is to pass the identity of the context in an explicit type parameter. Note how the constructor of <code>Helper</code> uses <code>c.type</code> to express the fact that <code>Helper.c</code> is the same as the original <code>c</code>. Scala's type inference can't figure this out on its own, so we need to help it.</p>

{% highlight scala %}
scala> class Helper[C <: Context](val c: C) {
     | def generate: c.Tree = ???
     | }
defined class Helper

scala> def impl(c: Context): c.Expr[Unit] = {
     | val helper = new Helper[c.type](c)
     | c.Expr(helper.generate)
     | }
impl: (c: scala.reflect.macros.Context)c.Expr[Unit]
{% endhighlight %}

<h2>7. FAQ</h2>

<p>You're very much welcome to explore our <a href="/documentation/index.html">Documentation</a> section.</p>

<p>From the docs you can learn the following techniques:</p>

<ul>
  <li>How to create trees that correspond to the code you want to generate (hint: refer to our "Learn to learn" slides from <a href="/talks/2012-04-28-MetaprogrammingInScala210.pdf">reflection talk</a>)</li>
  <li>How to write a generic macros (hint: check out an example from <a href="/documentation/specification.html">the spec</a>)</li>
  <li>How to display custom warnings and errors (hint: check out the <code>FrontEnds</code> API in <a href="/documentation/reference.html">the reference</a>)</li>
  <li>How to compose trees in a type-safe and concise manner (hint: spec again, take a look at the "Splicing" section)</li>
</ul>

<p>If you're stuck or something is unclear, we're eager to help everyone.
Be sure to ask us on the <a href="{{site.google.group.url}}">mailing list</a>
or drop us a line at <a href="mailto:{{site.email}}">{{site.email}}</a></p>

<h2>7. More examples</h2>

<p>Scala macros have quite a few early adopters. Thanks to active community involvement, we have been able to rapidly prototype,
and now there's some code that can be used as a reference:</p>

<p><a href="https://github.com/typesafehub/slick">SLICK</a>: Scala language integrated connectivity kit developed by Typesafe and EPFL,
uses macros to provide a transparent front-end to a database query engine.</p>

<p><a href="https://github.com/retronym/macrocosm">Macrocosm</a>: Jason Zaugg's playground. Features fancy assertions, loggers,
compile-time checking for regexes and binary literals, and even an optimized foreach. Interesting stuff!</p>

<p><a href="https://github.com/pniederw/expecty">Expecty</a>: Power assertions as known from Groovy and Spock to the Scala language.
Pimps vanilla assertions so hard, that they start printing values of sub-expressions.</p>

<p>Also it's not a bad idea to take a look at <a href="https://github.com/scala/scala/tree/master/test/files/run">our unit tests</a>.
They are not very descriptive, but they explore uses of macros in unexpected settings (implicit macros, anyone? =))