---
layout: default
title: Future
comments: false
plusone: false
---

<p>
  This page describes the features that we're planning to explore and, possibly, include in our future releases.
  We believe that, similarly to <code>macro defs</code> these features can make Scala simpler and more orthogonal.
</p>

<p>
  <b>Macro types</b> are used to parametrically generate classes and traits that can be utilized directly, extended or mixed in, similarly to vanilla Scala classes.
  Moreover, macro types can also declare new package objects full of various definitions that can be imported using regular Scala import syntax.
</p>

<p>
  This facility can be leveraged to achieve something similar to type providers from F#. After creating a suitable macro type for such domains as database access,
  inter-process interoperability, web services, the programmer is relieved from the necessity to generate and foster boilerplate classes.
  Since macro types are based on a solid foundation of a macro system, they provide more flexibility than ad-hoc approaches to these problems.
</p>

<p>
  The notion of type providers is elaborated in greater detail in the <a href="/usecases/type-providers.html">"Type providers"</a> case study, but for now let's just proceed with the code.
  Same as before, if something is confusing, ask us on the <a href="{{site.google.group.url}}">mailing list</a>
  or drop us a line at <a href="mailto:{{site.email}}">{{site.email}}</a>:
</p>

{% highlight scala %}
// macro types are, in essence, the same as macro defs
// they are also functions that take ASTs and produce ASTs
// take a look at the body of this macro in the "Type Providers" use case
type MySqlDb(connString: String) = macro ...

// analogously to macro defs that can be used in place of regular defs,
// macro types can be used wherever you can use a type
// in this example, we mix in a macro trait into a normal class
// under the covers the macro will produce a synthetic trait that will be used
// as usual, all this will happen during the compile-time
type MyDb = Base with MySqlDb("Server=127.0.0.1;Database=Foo;")

// macro types generate fields, methods, inner classes and whatever else
// this "virtual" code can be used as if it was written manually
import MyDb._
val products = new MyDb().products
products.filter(p => p.name.startsWith("foo")).toList
{% endhighlight %}

<p>
  <b>Macro annotations</b> can be used to perform final postprocessing on program elements (classes, methods, expressions) after all other macros have been expanded.
  Macro annotations look in the very same way as regular annotations do, however,
  they are not just static participants of the compilation pipeline, but can actively participate in it.
</p>

<p>
  Potential areas of applicability of this feature include aspect-oriented programming, implementing new idioms
  (e.g. with macro annotations it's possible to introduce <code>@lazy</code> parameters or even work on sub-method level to, say, bless certain variables)
  and automatizing chores on a small scale (read up more on that in the <a href="/usecases/generation-of-boilerplate.html">"Generation of boilerplate"</a> case study).
</p>

<p>
  The example below features the <code>@Serializable</code> macro that reflects upon members of the annotated class,
  generates serialization/deserialization routines and implements the <code>Serializable</code> interface that exposes them
  (compiler API we're using here is completely fictional, it will be refined when Scala reflection API gets stabilized):
</p>

{% highlight scala %}
// in line with other flavors of macros, macro annotation transform ASTs
// however, the transformee does not come from the arguments list
// (after all, annotations might have arguments of its own)
// instead, the affect program entity is provided in a special implicit parameter
annotation Serializable = macro ...

// annotations get applied after everything else (other macros, syntactic sugar)
// that's why Serializable will see all the members of Person
// regardless of whether they come from a case class sugar
// or from Entity (be it a regular class or a macro class)
@Serializable
case class Person(firstName: String, lastName: String) extends Entity { ... }
{% endhighlight %}

