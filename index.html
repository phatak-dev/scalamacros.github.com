---
is_index: true
layout: default
comments: false
plusone: true
---

<p>
  This is the home page of project Kepler, an ongoing effort towards bringing <b>compile-time metaprogramming</b> to Scala.
  Our flavor of macros is reminiscent of Lisp macros, adapted to incorporate type safety and rich syntax.
  Unlike infamous C/C++ preprocessor macros, Scala macros: 1) are written in full-fledged Scala,
  2) work with expression trees, not with raw strings, 3) cannot change syntax of Scala.
  You can learn more about our vision of metaprogramming from <a href="/talks.html">our talks</a>.
</p>

<p>
  <a href="/sips/macros.html">We propose</a> to enrich Scala with two flavors of macros: <b>macro defs</b> and <b>macro types</b>. 
  Both kinds of macros can be used wherever their vanilla analogues are used, but they are treated differently by the compiler,
  providing <a href="/usecases.html">novel ways to analyze and generate code</a>.
</p>

<p>
  <b>Macro defs</b> are about morphing a program during the compile-time. Whenever a compiler sees an invocation of a method declared as a <code class="scala"><span class="n">macro def</span></code>,
  it immediately calls its implementation that analyzes the program and/or generates new code at the call site (so called "macro expansion").
</p>

<p>
  The following example describes a type-safe <code>printf</code> function. 
  Being a macro, <code>printf</code> formats the output during the compile-time, which provides safety guarantees inaccessible to regular approaches.
  This notion can be generalized to serve the needs of many other domains, the topic that is dwelled upon in the
  <a href="/usecase/compile-time-verification.html">"Compile-time verification"</a> case study on this site.
</p>

<p>
  However, let's proceed with the code example that outlines the implementation and usage of the <code>printf</code> macro along with the result of its expansion.
  If certain aspects of the code are unclear, consult our walkthroughs (<a href="/talks/2011-10-18-WhatsUp.pdf">English</a>, <a href="/talks/2011-10-29-RuProjectKepler.pdf">Russian</a>)
  or drop us a line at <a href="mailto:dev@scalamacros.org">dev@scalamacros.org</a>:
</p>

{% highlight scala %}
macro def printf(format: String, params: Any*) {
  val (evals, refs) = parse(format, params)
  val seq = evals + refs.map(x => c"print($x)")
  c"$seq"
}

printf("Value = %d", 123 + 877)

val p1 = (123 + 877): Int
print("Value = ")
print(p1)
{% endhighlight %}

<p>
  <b>Macro types</b> are used to parametrically generate classes and traits that can be utilized directly, extended or mixed in, similarly to vanilla Scala classes.
  Moreover, macro types can also declare new package objects full of various definitions that can be imported using regular Scala import syntax.
</p>

<p>
  This facility can be leveraged to achieve something similar to type providers from F#. After creating a suitable macro type for such domains as database access,
  inter-process interoperability, web services, the programmer is relieved from the necessity to generate and foster boilerplate classes.
  Since macro types are based on a solid foundation of a macro system, they provide more flexibility than ad-hoc approaches to these problems.
</p>

<p>
  The notion of type providers is elaborated in greater detail in the <a href="/usecases/type-providers.html">"Type providers"</a> case study, and now let's proceed with the code.
  Same as before, if certain aspects of the code are unclear, take a look at the walkthroughs (<a href="/talks/2011-10-18-WhatsUp.pdf">English</a>, 
  <a href="/talks/2011-10-29-RuProjectKepler.pdf">Russian</a>) or ask us at <a href="mailto:dev@scalamacros.org">dev@scalamacros.org</a>:
</p>

{% highlight scala %}
macro trait MySqlDb(connString: String) = ...
type MyDb = Base with MySqlDb("Server=127.0.0.1;Database=Foo;")

import MyDb._
val products = new MyDb().products
products.filter(p => p.name.startsWith("foo")).toList
{% endhighlight %}

<p>
  Macros significantly simplify <b>code analysis and code generation</b>, which makes them a tool of choice for a multitude of <a href="/usecases.html">real-world use cases</a>.
  Scenarios that traditionally involve writing and maintaining boilerplate can be addressed with macros in concise and maintainable way.
  Therefore we believe that macros are a valuable asset to Scala programming language.
</p>